

:原则
    ::单一职责原则->30
    ::开放封闭原则->34
    ::依赖倒转原则->38
    ::迪米特法则->100
        (A类型 与 B类型的交互, 可以引入中间类)
    --
    备注:明确什么会变化, 什么不会变化; 最终将变化因子 抽象化
--

:创建型
    ::单列模式->236
    ::工厂方法模式->95
    ::抽象工厂模式->141
    ::建造者模式->145
    ::原型模式->105
--

:结构型
    ::适配器模式->197  
    ::桥接模式->220
    ::装饰模式->73
    ::组合模式->216
    ::享元模式->296
    ::代理模式->88
    ::外观模式->134
--

:行为型一
    ::观察者模式->157
    ::模板方法模式->122
    ::命令模式->269
    ::状态模式->189
    ::职业链模式->276
--

:行为型二
    ::解释器模式->279
    ::中介者模式->286
    ::访问者模式->327
    ::策略模式->45
    ::迭代器模式->229
    ::备忘录模式->209
--

:工厂方法模式
    能力: 封装new 这个行为, 客户端仅知道创建了一个对象, 却无需知道时什么对象.
    例如: 通过一个工厂, new出加密类, 客户端却不知道什么加密算法

    定义一个[基类A], 虚函数为[创建对象]
    定义一个[MD5工厂], 继承[基类A], [创建对象]函数调用 new [MD5类], 并返回 [基类B]
    定义一个[CRC工厂], 继承[基类A], [创建对象]函数调用 new [CRC类], 并返回 [基类B]
    定义一个[AES工厂], 继承[基类A], [创建对象]函数调用 new [AES类], 并返回 [基类B]

    定义一个[基类B], 虚函数为[加密]
    定义一个[MD5算法类], 继承[基类B], [加密]函数 实现加密算法
    定义一个[CRC算法类], 继承[基类B], [加密]函数 实现加密算法
    定义一个[AES算法类], 继承[基类B], [加密]函数 实现加密算法

    客户端 通过[基类A]->[创建对象]->[基类B]->[加密]
    备注:[基类A] 函数参数. 这样业务逻辑直接通过[基类A]调用[创建对象]
    使用场景: 需要调用new的逻辑, 故后端开发很少涉及这样的逻辑
    使用场景2: 根据玩家UID 返回一个[基类A], 用户根据[基类A]调用[创建对象]->[基类B]->[加密]
    备注2: [基类A]生命周期等于玩家内存数据生命周期. 用户完成了加密的行为, 却不知道使用什么算法加密的.
--

:抽象工厂模式
    工厂方法的扩展, 不太实用. 我宁愿定义2个 工厂方法
--

:建造者模式
    高内聚的创建对象模式. 简单粗暴, 但很实用. (可以创建 一个世界, 一个垃圾桶 或 一个缝合怪)
    备注: 将需要的部件, 都放入一个类里, 接着提供[创建对象]函数. 然后客户端通过基类调用[创建对象]函数
--

:适配器模式
    能力: 封装已经存在的类
    例如: 封装所有加密库
    定义一个[基类A], 虚函数为[加密]

    定义一个[MD5适配], 继承[基类A], 成员变量有[MD5类], [加密]函数调用 多个[MD5类]的函数
    安装 开源的MD5库

    定义一个[CRC适配], 继承[基类A], 成员变量有[CRC类], [加密]函数调用 多个[CRC类]的函数
    安装 开源的CRC库

    定义一个[AES适配], 继承[基类A], 成员变量有[AES类], [加密]函数调用 多个[AES类]的函数
    安装 开源的AES库
--

:桥接模式
    能力:定义A,B 2个行为, A有N种可能, B有M种可能. N选一 + M选一的 行为模式
    例如:下载URL数据, 并解密. N种下载方式, M种解密方式

    定义一个[基类A], 虚函数为[下载-解密] 和 成员变量有[基类-解密]
    定义一个[https下载类], 继承[基类A], [下载-解密]实现https下载逻辑, 并调用[基类-解密]的解密接口
    定义一个[svn下载类], 继承[基类A], [下载-解密]实现svn下载逻辑, 并调用[基类-解密]的解密接口
    定义一个[ftp下载类], 继承[基类A], [下载-解密]实现ftp下载逻辑, 并调用[基类-解密]的解密接口

    定义一个[基类-解密], 虚函数为[解密]
    定义一个[MD5算法类], 继承[基类-解密], [解密]函数 实现解密算法
    定义一个[CRC算法类], 继承[基类-解密], [解密]函数 实现解密算法
    定义一个[AES算法类], 继承[基类-解密], [解密]函数 实现解密算法
--

:装饰模式
    能力:定义一个类, 包含 具有前后关系的N个类
    例如:定义加密类, 包含N次加密, 允许重复.

    定义一个[基类A], 虚函数为[加密]
    定义一个[装饰类], 继承[基类A], 成员变量[-基类A-]指针, 在构造函数设置成员变量[-基类A-]指针

    定义一个[MD5算法类], 继承[装饰类], [加密]函数 调用[装饰类]->[-基类A-]->[加密], 接着执行 本函数的加密算法
    定义一个[CRC算法类], 继承[装饰类], [加密]函数 调用[装饰类]->[-基类A-]->[加密], 接着执行 本函数的加密算法
    定义一个[AES算法类], 继承[装饰类], [加密]函数 调用[装饰类]->[-基类A-]->[加密], 接着执行 本函数的加密算法

    用例:
        auto o1 = new 基类A; 
        auto o2 = new MD5算法类(o1);
        auto o3 = new CRC算法类(o2);
        auto o4 = new AES算法类(o3);
        auto o5 = new MD5算法类(o4);    //o5的 包含了MD5, CRC, AES, MD5
    --
--

:组合模式
    能力: 实现树状结构. 例如文件系统.
    定义一个[基类A], 定义 所有方法
    定义一个[文件夹类], 继承[基类A], 成员变量list<基类A>, 实现所需的方法
    定义一个[文本类] , 继承[基类A], 实现所需的方法
--

:享元模式
    能力: 通过标识, 获取已经存在的对象
    例如: 通过标识,返回加密对象

    定义一个[基类A], 虚函数为[加密]
    定义一个[MD5算法类], 继承[基类A], [加密]函数 实现加密算法
    定义一个[CRC算法类], 继承[基类A], [加密]函数 实现加密算法
    定义一个[AES算法类], 继承[基类A], [加密]函数 实现加密算法

    定义一个[享元类], 成员变量 map<标识, 基类A>, 成员函数 实现通过标识返回map中存在的对象 
        构造时 new出N个算法类放入 list 

--

:代理模式
    能力: 就是一个简单的函数封装

    定义一个[基类-解密], 虚函数为[解密] , [代理解密]函数 执行前置逻辑, 调用[解密]函数, 执行后置逻辑  
    定义一个[MD5算法类], 继承[基类-解密], [解密]函数 实现解密算法
    定义一个[CRC算法类], 继承[基类-解密], [解密]函数 实现解密算法
    定义一个[AES算法类], 继承[基类-解密], [解密]函数 实现解密算法
--

:外观模式
    高内聚的对象. 简单粗暴, 但很实用. (可能会是一个世界, 一个垃圾桶 或 缝合怪)
--

:结构型模式与行为型模式的区别
    结构型模式 注重结构的封装
    行为型模式 注重行为的封装
--

::无法区分 装饰模式和观察者模式

:观察者模式
    能力: 类似容器的添加, 删除, 遍历执行事件. 
    例如: 容器中存入 N个模块, 通过遍历 调用各个模块的函数

    定义一个[基类-观察者], 虚函数为[行为]
    定义一个[发邮件], 继承[基类-观察者], [行为]函数 实现邮件发送逻辑
    定义一个[缴纳水电费], 继承[基类-观察者], [行为]函数 实现支付逻辑
    定义一个[打扫卫生], 继承[基类-观察者], [行为]函数 实现打扫逻辑
    定义一个[准备食物], 继承[基类-观察者], [行为]函数 实现准备食物逻辑

    定义一个[基类-被观察者], 成员变量 list<基类-观察者-指针> , 成员函数 增加, 删除, 执行全部行为
    定义一个[小管家], 继承[基类-被观察者], 成员变量 略
    用例: 创建小管家 增加 缴纳水电费,打扫卫生行为, 并将对象放入定时器, 到周末时调用 执行全部行为
    用例: 创建小管家 增加 发邮件,打扫卫生,准备食物, 并将对象放入定时器, 到生日时调用 执行全部行为
--

:模板方法模式
    能力: 子类继承基类, 子类获得基类的行为.
--

:命令模式
    能力: 将请求封装成对象. 以便管理.
    例如: 将协议请求封装成对象, linux信号封装成对象, 然后放入队列等待执行. 

    定义一个[接收者], [购买]函数; [使用]函数; [写入日志]函数; [更新在线时间]函数; [安全关闭]函数

    定义一个[基类-命令], 虚函数有[执行] 和 [异常处理]
    定义一个[购买物品], 继承[基类-命令], 有成员变量[接收者], [行为]函数 调用[接收者]->[购买]; [异常处理]函数 [接收者]->[写入日志]
    定义一个[使用物品], 继承[基类-命令], 有成员变量[接收者], [行为]函数 调用[接收者]->[使用]; [异常处理]函数 [接收者]->[写入日志]
    定义一个[心跳协议], 继承[基类-命令], 有成员变量[接收者], [行为]函数 调用[接收者]->[更新在线时间]; [异常处理]函数 无
    定义一个[关服信号], 继承[基类-命令], 有成员变量[接收者], [行为]函数 调用[接收者]->[安全关闭]; [异常处理]函数 无

    备注: 根据协议ID和信号 封装请求, 并放入队列等待处理.
--

:状态模式
    能力: 消除复杂的if-else逻辑; 处理数据, 并转到下个状态
    优点: 创建订单时, 无需知道有多少个状态
    缺点: 当前状态类, 需要知道下个状态.

    定义一个[订单], 有成员变量 [基类-状态]指针 和 订单ID, [订单行为]函数 调用[基类-状态]->[行为], 并设置下个状态

    定义一个[基类-状态], 虚函数为[行为]
    定义一个[备货], 继承[基类-状态], 备货进度, [行为]函数 备货成功 返回[发货]指针, 失败返回[退款]指针, 正在备货则返回 this
    定义一个[发货], 继承[基类-状态], 成员变量有物品ID, [行为]函数 发货成功 返回[评价]指针, 失败返回[退款]指针, 正在发货则返回 this
    定义一个[退款], 继承[基类-状态], [行为]函数 退款成功 返回[评价]指针, 失败 空
    定义一个[评价], 继承[基类-状态], [行为]函数 评价成功 返回 空, 失败 空
    用例: 创建[订单] 定时处理订单. 直到订单结束.
    备注: 订单是唯一的, 但是状态会因需求而变, 每个状态的处理逻辑也会因需求而变
--

:职业链模式
    能力: 消除复杂的if-else逻辑; 处理数据, 并转到下个节点
    优点: 当前状态类, 无需知道下个[节点]
    缺点: 创建订单时, 需要明确多个[节点]
    
    定义一个[基类-节点], 虚函数为[行为], 成员变量 [基类-节点]指针, 成员函数 [设置下一个]
    定义一个[主城], 继承[基类-节点], 函数[行为] 状态回满
    定义一个[雪地], 继承[基类-节点], 函数[行为] 速度减半
    定义一个[火山], 继承[基类-节点], 函数[行为] 血量减半

    用例: 
        auto o1 = new [主城]; 
        auto o2 = new [雪地];
        auto o3 = new [火山];
        o1->设置下一个(o2);
        o2->设置下一个(o3);
    --
    与单向链表的差异: 每个节点 可以自定义成员函数和成员变量.
    备注: 职业链模式UML与装饰模式UML相比, 有点像简化版. 都实现了链式结构, 如同链表
--

:解释器模式
    不懂, 这个模式的网上例子怎么都是解释器.
--

:中介者模式
    能力: 简化对象与对象关联
    例如: 将N个对象放入容器, 接着Mgr管理该容器, 提供增加, 删除, 访问容器成员的接口函数

    定义一个[基类-文件], 虚函数为[写入], 成员变量 [管理类]指针
    定义一个[txt文件], 继承[基类-文件], [写入] 实现写入逻辑
    定义一个[doc文件], 继承[基类-文件], [写入] 实现写入逻辑
    定义一个[excel文件], 继承[基类-文件], [写入] 实现写入逻辑

    定义一个[管理类], 成员变量 map<文件名称, [基类-文件]指针>, 成员函数[发送] 实现查找指定对象, 调用对象->[写入]函数
--

:访问者模式
    能力1: 解决1对N的模型 
    例如: 每个[基类A]的实例, 都可以对应[创造]和[毁灭]
    能力2: Mgr 进行批量管理
    能力3: M选一的数据模型; 利用函数重载, 避免了if-else逻辑
    例如: [基类-机器]有3中类型的启动, 对应[药水][装备][随从];
    能力总结: 解决 1对N + M选一的数据模型

    定义一个Mgr, 成员变量 list<[基类A]指针> , 增加, 删除, 使用
    定义一个[基类A], 虚函数为[使用] 参数 [基类-机器]指针
    定义一个[药水], 继承[基类A], 函数[使用] 调用 [基类-机器]->[启动] 传入参数 this
    定义一个[装备], 继承[基类A], 函数[使用] 调用 [基类-机器]->[启动] 传入参数 this
    定义一个[随从], 继承[基类A], 函数[使用] 调用 [基类-机器]->[启动] 传入参数 this

    定义一个[基类-机器], 虚函数为[启动] 参数[药水]指针, [启动] 参数[装备]指针, [启动] 参数[随从]指针
    定义一个[创造], 继承[基类-机器], 实现 3个基类函数
    定义一个[毁灭], 继承[基类-机器], 实现 3个基类函数
--

:策略模式
    能力: 将N个对象的共同行为 抽象化, 接着用一个对象包装抽象接口
    例如: 有N个对象,继承同一个基类, 基类有纯虚函数[解密], 接着有个 正文类的成员变量是 该基类

    定义一个[基类-解密], 虚函数为[解密]
    定义一个[MD5算法类], 继承[基类-解密], [解密] 实现解密算法
    定义一个[CRC算法类], 继承[基类-解密], [解密] 实现解密算法
    定义一个[AES算法类], 继承[基类-解密], [解密] 实现解密算法

    定义一个[正文], 成员变量 待解密的数据和 [基类-解密]指针 
--

:迭代器模式
    能力: 将算法与数据分离. 迭代器类关联数据集合.
    备注: 如果没有数据集合, 仅仅一个数据对象, 那么用策略模式也能做到 数据与算法分离
    使用场景: 遍历容器; 排序;
--

:备忘录模式
    发起人类, 备忘录管理类, 备忘录类
    发起人 类似于 Role
    备忘录管理类 类似一个 备忘录类的缓存
    备忘录类  类似 玩家数据的proto对象
--


