
//调试
#if
print ( "#####" , debug.getinfo(1).name , debug.getinfo(1).currentline )


function trace (event, line)
    local s = debug.getinfo(2).short_src
    print(s .. ":##########" .. line)
end

function deal_pve_msg(n_mode)
	debug.sethook(trace, "l")
	local nRet = 0
	if n_mode == 1 then
		nRet = 4
	end
	
	if n_mode > 10 then
		nRet = 5
	end
	
	if n_mode > 20 then
		nRet = 5
	end

	debug.sethook()
end

--测试_代码
deal_pve_msg(1)

#end

//加载dll
#if
package.path = package.path ..';protobuf\\?.lua;proto\\?.lua';
package.cpath = package.cpath .. ';lib\\?.dll'

local lib_test =require "testlib"

print(lib_test.add(1, 2) )

#endif

//反射
#if
--lua 反射
for k,v in pairs(lib_test) do
	print(k,v)
end


for k,v in pairs(lib_test) do
	--print(k,v)
	if k == "add" then
		print(v(2,2) )
		break
	end
end

#endif

//位操作
#if

local bit =require "bit"

--bitIndex 范围[0-31]
function GetBit(srcNum, bitIndex )
	return bit.band(bit.rshift(srcNum, bitIndex), 1)
end

function SetBit(srcNum, bitIndex )
	return bit.bor(bit.lshift(1, bitIndex), srcNum)
end

function ResetBit(srcNum, bitIndex )
	local n1 = bit.bnot( bit.lshift(1, bitIndex) )
	return bit.band(n1, srcNum)
end


#end

//protobuff
#if 

-- 如果require失败，请参考lua中`package.path`的使用
local pb =require("Test_pb")

local test = pb.Test()
test.id = 1
test.name = "hello"
test.ary:append(1) -- 内置类型的repeated使用append()
test.ary:append(2)

local foo1 = pb.foos:add() -- 复合类型的repeated使用add()
foo1.fid = 1
foo1.fname = "foo1"
local foo2 = pb.foos:add()
foo2.fid = 2
foo2.fname = "foo2"
-- 序列化为字符串
local pb_data =test:SerializeToString()

-- 从字符串解析
local recover = pb.Test()
recover:ParseFromString(pb_data)
print(recover.id, recover.foos[1].name, recover.foos[2].name) 
#endif

//常用函数
#if

//字符串_切片
function string:split(sep)  
    local sep, fields = sep or ":", {}  
    local pattern = string.format("([^%s]+)", sep)  
    self:gsub(pattern, function (c) fields[#fields + 1] = c end)  
    return fields  
end 

//查找字符串
function StrFind(str_src , str_dst)
	for i_ = 1 , #str_src do
		local end_i = i_ + #str_dst - 1
		if end_i > #str_src then
			return 0
		end
		
		local b_ok = true
		for key_i = 1 , #str_dst do
			local begin_i = i_ + key_i - 1;
			if string.sub(str_src , begin_i , begin_i) ~= string.sub(str_dst , key_i , key_i ) then
				b_ok = false
				break;
			end
		end
		
		if b_ok == true then
			return i_
		end
	end
	return 0
end

#end





